import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as l,o as n}from"./app-_9vaDOHR.js";const e={};function h(t,i){return n(),a("div",null,i[0]||(i[0]=[l(`<h1 id="作用域和作用域链" tabindex="-1"><a class="header-anchor" href="#作用域和作用域链"><span>作用域和作用域链</span></a></h1><h2 id="一-作用域" tabindex="-1"><a class="header-anchor" href="#一-作用域"><span>一.<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Scope" target="_blank" rel="noopener noreferrer">作用域</a></span></a></h2><h3 id="在javascript中-作用域-scope-定义了变量和函数的可访问范围和生命周期。它是一套规则-用于确定在代码的哪些部分可以查找和使用特定的变量或函数。" tabindex="-1"><a class="header-anchor" href="#在javascript中-作用域-scope-定义了变量和函数的可访问范围和生命周期。它是一套规则-用于确定在代码的哪些部分可以查找和使用特定的变量或函数。"><span><strong>在JavaScript中，作用域（Scope）定义了变量和函数的可访问范围和生命周期。它是一套规则，用于确定在代码的哪些部分可以查找和使用特定的变量或函数。</strong></span></a></h3><aside><ol><li>查找目的是对<strong>变量赋值</strong>就会使用 <strong>LHS查询</strong></li><li>如果目的是<strong>获取变量</strong>的值，就会使用<strong>RHS查询</strong></li></ol></aside><h3 id="_1-全局作用域-global-scope" tabindex="-1"><a class="header-anchor" href="#_1-全局作用域-global-scope"><span>1. 全局作用域（Global Scope）</span></a></h3><p>在最外层定义的变量或函数，可以在整个程序中访问。</p><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> globalVar</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;I&#39;m global&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> globalFunction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;I&#39;m also global&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-函数作用域-function-scope" tabindex="-1"><a class="header-anchor" href="#_2-函数作用域-function-scope"><span>2. 函数作用域（Function Scope）</span></a></h3><p>在函数内部定义的变量，只能在该函数内部访问。</p><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> myFunction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> localVar</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;I&#39;m local&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">localVar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 可以访问</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">localVar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 错误：localVar未定义</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-块级作用域-block-scope" tabindex="-1"><a class="header-anchor" href="#_3-块级作用域-block-scope"><span>3. 块级作用域（Block Scope）</span></a></h3><p>ES6引入了let和const关键字，它们创建的变量具有块级作用域，所声明的变量在指定块的作用域外无法被访问。</p><p><strong>let：</strong></p><ul><li>用于声明可以重新赋值的变量</li><li>具有块级作用域</li><li>不允许在同一作用域内重复声明</li></ul><p><strong>const：</strong></p><ul><li>用于声明常量，即一旦赋值就不能更改的变量</li><li>也具有块级作用域</li><li>必须在声明时初始化</li><li>不允许重新赋值，但如果值是对象或数组，其属性或元素可以修改</li></ul><p>块级作用域在以下情况下创建：</p><ul><li>在函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ul><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> blockVar</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;I&#39;m in a block&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> blockConst</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;I&#39;m also in a block&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">blockVar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 错误：blockVar未定义</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">blockConst</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 错误：blockConst未定义</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-词法作用域-lexical-scope" tabindex="-1"><a class="header-anchor" href="#_4-词法作用域-lexical-scope"><span>4. 词法作用域（Lexical Scope）</span></a></h3><p>内部函数可以访问外部函数的变量，这种嵌套的作用域链称为词法作用域。（词法作用域由书写代码时函数声明的位置来决定的。）</p><aside><figure><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/0a22064a-9355-4b63-8e5e-c72c52f98054/97e77716-18a6-4c96-b152-650b25db61e1/2bff44257575ce1cd04926de8bcb44f.jpg" alt="2bff44257575ce1cd04926de8bcb44f.jpg" tabindex="0" loading="lazy"><figcaption>2bff44257575ce1cd04926de8bcb44f.jpg</figcaption></figure><ol><li>全局作用域（图中的区域1）：</li></ol><ul><li>这是最外层的作用域，包含了整个代码。</li><li>在这里定义了函数foo(a)和调用foo(2)。</li></ul><ol><li>foo函数作用域（图中的区域2）：</li></ol><ul><li>这是foo函数的内部作用域。</li><li>在这里，参数a的值为2（来自函数调用foo(2)）。</li><li>定义了变量b，其值为a * 2，即4。</li><li>还定义了内部函数bar(c)。</li></ul><ol><li>bar函数作用域（图中的区域3）：</li></ol><ul><li>这是bar函数的内部作用域，嵌套在foo函数作用域内。</li><li>这里可以访问外部作用域（foo函数）中的变量a和b。</li><li>有一个参数c，其值来自bar(b*3)的调用，即12。</li><li>函数内部调用console.log(a,b,c)，会输出2,4,12。</li></ul><p>词法作用域的关键点：</p><ul><li>内部函数（如bar）可以访问外部函数（如foo）的变量。</li><li><strong>作用域是根据代码中函数定义的位置来确定的，而不是函数调用的位置。</strong></li><li>这种嵌套的作用域链允许内部函数访问外部作用域的变量，形成了闭包（closure）。</li></ul></aside><h2 id="二-作用域链" tabindex="-1"><a class="header-anchor" href="#二-作用域链"><span>二.作用域链</span></a></h2><h3 id="_1-什么是自由变量" tabindex="-1"><a class="header-anchor" href="#_1-什么是自由变量"><span>1.什么是自由变量？</span></a></h3><aside> 💡 <p>自由变量是指在函数内部使用的变量，但它既不是函数的参数，也不是函数的局部变量。换句话说，它是在函数外部定义的变量，但在函数内部被引用。</p></aside><ul><li><strong>自由变量的特点：</strong><ul><li>它在函数内部被使用，但不是在函数内部定义的。</li><li>它通常来自于函数的外部作用域（例如，父函数的作用域或全局作用域）。</li><li>自由变量是闭包形成的重要元素之一。</li></ul></li></ul><p>在JavaScript中，自由变量的访问是通过作用域链实现的。当函数需要访问一个变量时，它首先在自己的作用域中查找。如果没有找到，就会沿着作用域链向外查找，直到找到该变量或到达全局作用域。</p><p>这个概念与页面中提到的作用域链密切相关。作用域链允许内部函数访问外部作用域的变量，这正是自由变量的工作原理。</p><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 100 这里 a 就是自由变量</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 200</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">fn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="作用域链的形成过程" tabindex="-1"><a class="header-anchor" href="#作用域链的形成过程"><span>作用域链的形成过程</span></a></h3><ol><li>**在函数创建时，它的作用域链就已经确定了。**这个作用域链包括：</li></ol><ul><li>函数自身的变量对象（包含其参数、内部声明的变量等）</li><li>函数的外部环境的变量对象</li><li>全局环境的变量对象</li></ul><ol><li>当函数执行时，会创建一个执行环境（execution context）。这个执行环境的作用域链是基于函数的作用域链创建的。</li></ol><h3 id="作用域链的作用" tabindex="-1"><a class="header-anchor" href="#作用域链的作用"><span>作用域链的作用</span></a></h3><ol><li>变量查找：当代码需要访问一个变量时，它会首先在当前作用域中查找。如果没有找到，就会沿着作用域链向外层作用域查找，直到全局作用域。</li><li>闭包实现：作用域链使得内部函数可以访问外部函数的变量，这是闭包实现的基础。</li><li>命名空间：作用域链有助于避免命名冲突，因为内部作用域可以遮蔽外部作用域的同名变量。</li></ol><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> global</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;global&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> outer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> outer</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;outer&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> inner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> inner</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;inner&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">inner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在当前作用域找到</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">outer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在外层作用域找到</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">global</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在全局作用域找到</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    inner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">outer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，inner函数的作用域链包括：inner的变量对象 -&gt; outer的变量对象 -&gt; 全局变量对象。这就是为什么inner函数可以访问所有这些变量的原因。</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结：</span></a></h1><p><strong>1. 作用域（Scope）</strong></p><ul><li>定义了变量和函数的可访问范围和生命周期</li><li>包括全局作用域、函数作用域和块级作用域</li><li>ES6引入的let和const关键字创建块级作用域</li></ul><p><strong>2. 词法作用域（Lexical Scope）</strong></p><ul><li>内部函数可以访问外部函数的变量</li><li>由函数定义的位置决定，而非调用位置</li></ul><p><strong>3. 自由变量</strong></p><ul><li>在函数内部使用但不在函数内定义的变量</li><li>通过作用域链访问</li></ul><p><strong>4. 作用域链</strong></p><ul><li>在函数创建时确定，包括函数自身、外部环境和全局环境的变量对象</li><li>用于变量查找、闭包实现和避免命名冲突</li></ul><p>这些概念共同构成了JavaScript中变量访问和函数执行的基础机制，对理解代码的运行和编写高效的JavaScript程序至关重要。</p>`,48)]))}const r=s(e,[["render",h],["__file","JavaScript01.html.vue"]]),d=JSON.parse('{"path":"/JavaScript/JavaScript01.html","title":"作用域和作用域链","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"一.作用域","slug":"一-作用域","link":"#一-作用域","children":[{"level":3,"title":"在JavaScript中，作用域（Scope）定义了变量和函数的可访问范围和生命周期。它是一套规则，用于确定在代码的哪些部分可以查找和使用特定的变量或函数。","slug":"在javascript中-作用域-scope-定义了变量和函数的可访问范围和生命周期。它是一套规则-用于确定在代码的哪些部分可以查找和使用特定的变量或函数。","link":"#在javascript中-作用域-scope-定义了变量和函数的可访问范围和生命周期。它是一套规则-用于确定在代码的哪些部分可以查找和使用特定的变量或函数。","children":[]},{"level":3,"title":"1. 全局作用域（Global Scope）","slug":"_1-全局作用域-global-scope","link":"#_1-全局作用域-global-scope","children":[]},{"level":3,"title":"2. 函数作用域（Function Scope）","slug":"_2-函数作用域-function-scope","link":"#_2-函数作用域-function-scope","children":[]},{"level":3,"title":"3. 块级作用域（Block Scope）","slug":"_3-块级作用域-block-scope","link":"#_3-块级作用域-block-scope","children":[]},{"level":3,"title":"4. 词法作用域（Lexical Scope）","slug":"_4-词法作用域-lexical-scope","link":"#_4-词法作用域-lexical-scope","children":[]}]},{"level":2,"title":"二.作用域链","slug":"二-作用域链","link":"#二-作用域链","children":[{"level":3,"title":"1.什么是自由变量？","slug":"_1-什么是自由变量","link":"#_1-什么是自由变量","children":[]},{"level":3,"title":"作用域链的形成过程","slug":"作用域链的形成过程","link":"#作用域链的形成过程","children":[]},{"level":3,"title":"作用域链的作用","slug":"作用域链的作用","link":"#作用域链的作用","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.65,"words":1694},"filePathRelative":"JavaScript/JavaScript01.md"}');export{r as comp,d as data};

import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as l,o as n}from"./app-_9vaDOHR.js";const e={};function h(t,i){return n(),a("div",null,i[0]||(i[0]=[l(`<h1 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h1><h2 id="闭包的定义" tabindex="-1"><a class="header-anchor" href="#闭包的定义"><span>闭包的定义</span></a></h2><p><strong>闭包</strong>是由捆绑起来（封闭的）的函数和函数周围状态（<strong>词法环境</strong>）的引用组合而成。换言之，闭包让函数能访问它的外部作用域。在 JavaScript 中，闭包会随着函数的创建而同时创建。</p><h2 id="闭包的特点" tabindex="-1"><a class="header-anchor" href="#闭包的特点"><span>闭包的特点</span></a></h2><ul><li>函数嵌套：闭包通常涉及函数嵌套，即在一个函数内部定义另一个函数。</li><li>访问外部变量：内部函数可以访问外部函数的变量。</li><li>保持状态：闭包可以&quot;记住&quot;创建它时的环境。</li><li>封装性：闭包可以用来创建私有变量和方法。</li></ul><h2 id="闭包的工作原理" tabindex="-1"><a class="header-anchor" href="#闭包的工作原理"><span>闭包的工作原理</span></a></h2><p>当一个函数被创建并传递或返回时：</p><ol><li>它会保留对其定义时所在词法环境的引用。</li><li>这个环境包含了在函数定义时可见的所有变量。</li><li>即使原始的词法环境不再存在，函数仍然可以访问这些变量。</li></ol><h2 id="闭包的应用场景" tabindex="-1"><a class="header-anchor" href="#闭包的应用场景"><span>闭包的应用场景</span></a></h2><ul><li>数据隐藏和模块化：创建私有变量和函数。</li><li>回调函数：在异步编程中广泛使用。</li><li>函数工厂：动态生成函数。</li><li>柯里化（Currying）：将多参数函数转换为一系列单参数函数。</li></ul><h2 id="闭包的优缺点" tabindex="-1"><a class="header-anchor" href="#闭包的优缺点"><span>闭包的优缺点</span></a></h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点：</span></a></h3><ul><li>提高代码的可重用性。</li><li>封装变量，提供了一种状态隔离和封装的方式。</li><li>支持函数式编程。</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点：</span></a></h3><ul><li>可能导致内存泄漏，如果不正确使用。</li><li>在某些情况下可能影响性能。</li><li>可能使代码较难理解和维护。</li></ul><h2 id="闭包示例" tabindex="-1"><a class="header-anchor" href="#闭包示例"><span>闭包示例</span></a></h2><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> outerFunction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> y</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> innerFunction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">z</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> y</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> z</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> closure</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> outerFunction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">closure</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出: 35</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，innerFunction 形成了一个闭包，它可以访问 outerFunction 的参数 x 和局部变量 y，即使在 outerFunction 执行完毕后。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>闭包是 JavaScript 中一个强大而灵活的特性，它允许函数访问其词法作用域之外的变量。理解和正确使用闭包可以帮助开发者编写更加简洁、模块化和高效的代码。然而，也需要注意潜在的内存管理问题，确保在不需要时正确释放闭包。</p>`,20)]))}const p=s(e,[["render",h],["__file","JavaScript02.html.vue"]]),d=JSON.parse('{"path":"/JavaScript/JavaScript02.html","title":"闭包","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"闭包的定义","slug":"闭包的定义","link":"#闭包的定义","children":[]},{"level":2,"title":"闭包的特点","slug":"闭包的特点","link":"#闭包的特点","children":[]},{"level":2,"title":"闭包的工作原理","slug":"闭包的工作原理","link":"#闭包的工作原理","children":[]},{"level":2,"title":"闭包的应用场景","slug":"闭包的应用场景","link":"#闭包的应用场景","children":[]},{"level":2,"title":"闭包的优缺点","slug":"闭包的优缺点","link":"#闭包的优缺点","children":[{"level":3,"title":"优点：","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"缺点：","slug":"缺点","link":"#缺点","children":[]}]},{"level":2,"title":"闭包示例","slug":"闭包示例","link":"#闭包示例","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.9,"words":570},"filePathRelative":"JavaScript/JavaScript02.md"}');export{p as comp,d as data};
